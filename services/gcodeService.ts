import { Shape, ShapeType, MachineSettings } from '../types';

// A minimal "Stick Font" definition (0-1 normalized coordinates)
// Format: List of paths. Each path is a list of points.
const SIMPLE_FONT: Record<string, number[][][]> = {
  'A': [[[0,0], [0.5,1], [1,0]], [[0.2,0.4], [0.8,0.4]]],
  'B': [[[0,0], [0,1], [0.8,1], [0.8,0.5], [0,0.5], [0.8,0.5], [0.8,0], [0,0]]],
  'C': [[[1,0.2], [0.5,0], [0,0.5], [0.5,1], [1,0.8]]],
  'D': [[[0,0], [0,1], [0.6,1], [1,0.5], [0.6,0], [0,0]]],
  'E': [[[1,0], [0,0], [0,1], [1,1]], [[0,0.5], [0.8,0.5]]],
  'F': [[[0,0], [0,1], [1,1]], [[0,0.5], [0.8,0.5]]],
  'G': [[[1,0.8], [1,0.5], [0.5,0.5]], [[0.5,0.5], [1,0.2], [0.5,0], [0,0.5], [0.5,1], [1,0.8]]],
  'H': [[[0,0], [0,1]], [[1,0], [1,1]], [[0,0.5], [1,0.5]]],
  'I': [[[0.5,0], [0.5,1]], [[0,0], [1,0]], [[0,1], [1,1]]],
  'J': [[[1,1], [1,0.2], [0.5,0], [0,0.2]]],
  'K': [[[0,0], [0,1]], [[1,1], [0,0.5], [1,0]]],
  'L': [[[0,1], [0,0], [1,0]]],
  'M': [[[0,0], [0,1], [0.5,0.5], [1,1], [1,0]]],
  'N': [[[0,0], [0,1], [1,0], [1,1]]],
  'O': [[[0.5,0], [0,0.5], [0.5,1], [1,0.5], [0.5,0]]],
  'P': [[[0,0], [0,1], [0.8,1], [0.8,0.5], [0,0.5]]],
  'Q': [[[0.5,0], [0,0.5], [0.5,1], [1,0.5], [0.5,0]], [[0.7,0.3], [1,0]]],
  'R': [[[0,0], [0,1], [0.8,1], [0.8,0.5], [0,0.5], [1,0]]],
  'S': [[[1,0.8], [0.5,1], [0,0.8], [1,0.2], [0.5,0], [0,0.2]]],
  'T': [[[0.5,0], [0.5,1]], [[0,1], [1,1]]],
  'U': [[[0,1], [0,0.2], [0.5,0], [1,0.2], [1,1]]],
  'V': [[[0,1], [0.5,0], [1,1]]],
  'W': [[[0,1], [0.2,0], [0.5,0.5], [0.8,0], [1,1]]],
  'X': [[[0,0], [1,1]], [[0,1], [1,0]]],
  'Y': [[[0,1], [0.5,0.5]], [[1,1], [0.5,0.5]], [[0.5,0.5], [0.5,0]]],
  'Z': [[[0,1], [1,1], [0,0], [1,0]]],
  '0': [[[0.5,0], [0,0.5], [0.5,1], [1,0.5], [0.5,0]], [[0,0], [1,1]]], // Slashed zero
  '1': [[[0,0.8], [0.5,1], [0.5,0]], [[0,0], [1,0]]],
  '2': [[[0,0.8], [0.5,1], [1,0.8], [0,0], [1,0]]],
  '3': [[[0,0.8], [0.5,1], [1,0.8], [0.5,0.5]], [[0.5,0.5], [1,0.2], [0.5,0], [0,0.2]]],
  '4': [[[0.8,0], [0.8,1]], [[0,1], [0,0.4], [1,0.4]]],
  '5': [[[1,1], [0,1], [0,0.6], [0.5,0.6], [1,0.3], [0.5,0], [0,0.2]]],
  '6': [[[1,0.8], [0.5,1], [0,0.5], [0.5,0], [1,0.3], [0,0.5]]],
  '7': [[[0,1], [1,1], [0.5,0]]],
  '8': [[[0.5,0.5], [1,0.8], [0.5,1], [0,0.8], [0.5,0.5], [1,0.2], [0.5,0], [0,0.2], [0.5,0.5]]],
  '9': [[[0,0.2], [0.5,0], [1,0.5], [0.5,1], [0,0.7], [1,0.5]]],
  ' ': []
};

export const generateGCode = (shapes: Shape[], settings: MachineSettings): string => {
  const { feedRate, safeHeight, cutDepth } = settings;
  const lines: string[] = [];

  // Header
  lines.push('; Generated by CNC Forge AI');
  lines.push('G21 ; Metric units');
  lines.push('G90 ; Absolute positioning');
  lines.push(`G0 Z${safeHeight} ; Move to safe height`);
  lines.push('M3 S1000 ; Spindle on');

  shapes.forEach((shape) => {
    lines.push(`; Shape: ${shape.type} (ID: ${shape.id})`);
    
    switch (shape.type) {
      case ShapeType.RECTANGLE:
        // Move to start corner
        lines.push(`G0 X${shape.x} Y${shape.y}`);
        // Plunge
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        // Cut rectangle
        lines.push(`G1 X${shape.x + shape.width} Y${shape.y} F${feedRate}`);
        lines.push(`G1 X${shape.x + shape.width} Y${shape.y + shape.height}`);
        lines.push(`G1 X${shape.x} Y${shape.y + shape.height}`);
        lines.push(`G1 X${shape.x} Y${shape.y}`);
        // Retract
        lines.push(`G0 Z${safeHeight}`);
        break;

      case ShapeType.CIRCLE:
        // Move to start point (rightmost point of circle)
        lines.push(`G0 X${shape.x + shape.radius} Y${shape.y}`);
        // Plunge
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        // Cut circle (Clockwise)
        // I and J are relative offsets to the center from current position
        // Current: (x+r, y). Center: (x, y). Offset: (-r, 0)
        lines.push(`G2 X${shape.x + shape.radius} Y${shape.y} I-${shape.radius} J0 F${feedRate}`);
        // Retract
        lines.push(`G0 Z${safeHeight}`);
        break;

      case ShapeType.TEXT:
        lines.push(`; Text: "${shape.text}"`);
        // Note: This stick font generator doesn't currently support custom fonts like "Great Vibes".
        // It uses the standard stick font definition for toolpath generation.
        // However, we apply letter spacing and size.
        
        let currentX = shape.x;
        const letterSpacing = shape.letterSpacing || 0;
        const charSpacing = (shape.fontSize * 0.1) + letterSpacing;
        const charWidth = shape.fontSize * 0.6; // approx width for stick font
        
        for (const char of shape.text.toUpperCase()) {
            const paths = SIMPLE_FONT[char] || SIMPLE_FONT['?'] || [];
            
            if (paths.length === 0 && char !== ' ') {
                // Unknown char box
                lines.push(`; Unknown char: ${char}`);
                lines.push(`G0 X${currentX} Y${shape.y}`);
                lines.push(`G1 Z${-cutDepth}`);
                lines.push(`G1 X${currentX + charWidth} Y${shape.y}`);
                lines.push(`G1 X${currentX + charWidth} Y${shape.y + shape.fontSize}`);
                lines.push(`G1 X${currentX} Y${shape.y + shape.fontSize}`);
                lines.push(`G1 X${currentX} Y${shape.y}`);
                lines.push(`G0 Z${safeHeight}`);
            } else if (char === ' ') {
                // Just move
            } else {
                paths.forEach(path => {
                   if (path.length === 0) return;
                   
                   // Move to first point
                   const startX = currentX + (path[0][0] * charWidth);
                   const startY = shape.y + (path[0][1] * shape.fontSize);

                   lines.push(`G0 X${startX.toFixed(3)} Y${startY.toFixed(3)}`);
                   lines.push(`G1 Z${-cutDepth}`);
                   
                   for (let i = 1; i < path.length; i++) {
                       const px = currentX + (path[i][0] * charWidth);
                       const py = shape.y + (path[i][1] * shape.fontSize);
                       lines.push(`G1 X${px.toFixed(3)} Y${py.toFixed(3)}`);
                   }
                   lines.push(`G0 Z${safeHeight}`);
                });
            }
            currentX += charWidth + charSpacing;
        }
        break;
    }
    lines.push('');
  });

  // Footer
  lines.push('M5 ; Spindle off');
  lines.push('G0 X0 Y0 ; Return home');
  lines.push('M30 ; End program');

  return lines.join('\n');
};