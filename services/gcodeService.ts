
import { Shape, ShapeType, MachineSettings, LineShape, PolylineShape, HeartShape, TextShape, MirrorMode, RectangleShape, GroupShape, CircleShape } from '../types';
import opentype from 'opentype.js';

// Cache for loaded fonts
const fontCache: Record<string, opentype.Font> = {};

// Font URLs - Using GitHub Raw for reliable TTF access
const FONTS: Record<string, string> = {
    'Roboto Mono': '/fonts/RobotoMono-Regular.ttf',
    'Great Vibes': '/fonts/GreatVibes-Regular.ttf',
    'Open Sans': '/fonts/OpenSans-Regular.ttf',
    'Lato': '/fonts/Lato-Regular.ttf',
    'Montserrat': '/fonts/Montserrat-Regular.ttf',
    'Oswald': '/fonts/Oswald-Regular.ttf',
    'Playfair Display': '/fonts/PlayfairDisplay-Regular.ttf'
};

export const AVAILABLE_FONTS = Object.keys(FONTS);

export async function loadFont(fontFamily: string): Promise<opentype.Font | null> {
    const key = Object.keys(FONTS).find(k => fontFamily.toLowerCase().includes(k.toLowerCase())) || 'Roboto Mono';
    const url = FONTS[key];

    if (fontCache[url]) return fontCache[url];

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Network response was not ok for ${url}`);
        const buffer = await response.arrayBuffer();
        const font = opentype.parse(buffer);
        fontCache[url] = font;
        return font;
    } catch (err) {
        console.error(`Font load error for ${fontFamily} (${url}), trying fallback to Roboto Mono...`, err);
        if (url !== FONTS['Roboto Mono']) {
            return loadFont('Roboto Mono');
        }
        return null;
    }
}

export const generateGCode = async (shapes: Shape[], settings: MachineSettings): Promise<string> => {
    const { feedRate, safeHeight, cutDepth } = settings;
    const lines: string[] = [];
    lines.push('; Generated by CNC Forge AI');
    lines.push('G21 G90');
    lines.push(`G0 Z${safeHeight}`);
    lines.push('M3 S1000');
    lines.push('');

    // Track current tool position
    let currentX = 0;
    let currentY = 0;
    let currentZ = safeHeight;

    const smartMoveToStart = (x: number, y: number) => {
        const dist = Math.hypot(x - currentX, y - currentY);
        // If we are very close to the start point and already at cut depth, just continue
        if (dist < 0.01 && Math.abs(currentZ - (-cutDepth)) < 0.01) {
            return;
        }

        // If we are not at safe height and need to move to a new start, retract first
        if (currentZ < safeHeight) {
            lines.push(`G0 Z${safeHeight}`);
            currentZ = safeHeight;
        }

        // Move to X,Y
        lines.push(`G0 X${x.toFixed(3)} Y${y.toFixed(3)}`);
        currentX = x;
        currentY = y;

        // Plunge
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        currentZ = -cutDepth;
    };

    const processShape = async (shape: Shape, offsetX: number = 0, offsetY: number = 0) => {
        if (shape.type === ShapeType.GROUP) {
            const g = shape as GroupShape;
            // Recursively process children with cumulative offset
            for (const child of g.children) {
                await processShape(child, offsetX + g.x, offsetY + g.y);
            }
            return;
        }

        // Apply offset to coordinates
        const x = shape.x + offsetX;
        const y = shape.y + offsetY;

        switch (shape.type) {
            case ShapeType.RECTANGLE: {
                const r = shape as RectangleShape;
                const w = r.width;
                const h = r.height;
                const cr = r.cornerRadius || 0;

                let startX = x;
                let startY = y;
                if (cr > 0) {
                    startX = x + cr;
                    startY = y;
                }

                smartMoveToStart(startX, startY);

                if (cr > 0) {
                    lines.push(`G1 X${(x + w - cr).toFixed(3)} Y${y.toFixed(3)} F${feedRate}`);
                    lines.push(`G2 X${(x + w).toFixed(3)} Y${(y + cr).toFixed(3)} I0 J${cr.toFixed(3)}`);
                    lines.push(`G1 X${(x + w).toFixed(3)} Y${(y + h - cr).toFixed(3)}`);
                    lines.push(`G2 X${(x + w - cr).toFixed(3)} Y${(y + h).toFixed(3)} I-${cr.toFixed(3)} J0`);
                    lines.push(`G1 X${(x + cr).toFixed(3)} Y${(y + h).toFixed(3)}`);
                    lines.push(`G2 X${x.toFixed(3)} Y${(y + h - cr).toFixed(3)} I0 J-${cr.toFixed(3)}`);
                    lines.push(`G1 X${x.toFixed(3)} Y${(y + cr).toFixed(3)}`);
                    lines.push(`G2 X${(x + cr).toFixed(3)} Y${y.toFixed(3)} I${cr.toFixed(3)} J0`);
                } else {
                    lines.push(`G1 X${(x + w).toFixed(3)} Y${y.toFixed(3)} F${feedRate}`);
                    lines.push(`G1 X${(x + w).toFixed(3)} Y${(y + h).toFixed(3)}`);
                    lines.push(`G1 X${x.toFixed(3)} Y${(y + h).toFixed(3)}`);
                    lines.push(`G1 X${x.toFixed(3)} Y${y.toFixed(3)}`);
                }

                // Update current position to end point (which is same as start for closed loop)
                currentX = startX;
                currentY = startY;
                break;
            }

            case ShapeType.CIRCLE: {
                const c = shape as CircleShape;
                const startX = x + c.radius;
                const startY = y;

                smartMoveToStart(startX, startY);

                lines.push(`G2 X${(x + c.radius).toFixed(3)} Y${y.toFixed(3)} I-${c.radius.toFixed(3)} J0 F${feedRate}`);

                currentX = startX;
                currentY = startY;
                break;
            }

            case ShapeType.LINE: {
                const l = shape as LineShape;
                smartMoveToStart(x, y);

                const endX = l.x2 + offsetX;
                const endY = l.y2 + offsetY;

                lines.push(`G1 X${endX.toFixed(3)} Y${endY.toFixed(3)} F${feedRate}`);

                currentX = endX;
                currentY = endY;
                break;
            }

            case ShapeType.POLYLINE: {
                const p = shape as PolylineShape;
                if (p.points.length > 0) {
                    const first = p.points[0];
                    const startX = first.x + x;
                    const startY = first.y + y;

                    smartMoveToStart(startX, startY);

                    for (let i = 1; i < p.points.length; i++) {
                        const pt = p.points[i];
                        const nextX = pt.x + x;
                        const nextY = pt.y + y;
                        lines.push(`G1 X${nextX.toFixed(3)} Y${nextY.toFixed(3)} F${feedRate}`);
                        currentX = nextX;
                        currentY = nextY;
                    }
                }
                break;
            }

            case ShapeType.HEART: {
                const h = shape as HeartShape;
                const steps = 40;
                const firstPt = calculateHeartPoint(0, h, x, y);

                smartMoveToStart(firstPt.x, firstPt.y);

                for (let i = 1; i <= steps; i++) {
                    const t = (i / steps) * 2 * Math.PI;
                    const pt = calculateHeartPoint(t, h, x, y);
                    lines.push(`G1 X${pt.x.toFixed(3)} Y${pt.y.toFixed(3)} F${feedRate}`);
                    currentX = pt.x;
                    currentY = pt.y;
                }
                break;
            }

            case ShapeType.TEXT: {
                const textShape = shape as TextShape;
                lines.push(`; Text: "${textShape.text}"`);
                let fontToUse = await loadFont(textShape.fontFamily || 'Roboto Mono');

                if (!fontToUse) {
                    console.warn("Could not load font for text generation.");
                    break;
                }

                const mirrorMode = textShape.mirrorMode || (textShape.mirror ? MirrorMode.WHOLE : MirrorMode.NONE);

                if (mirrorMode === MirrorMode.CHAR) {
                    let cursorX = x;
                    for (const char of textShape.text) {
                        const path = fontToUse.getPath(char, cursorX, y, textShape.fontSize);
                        let lastX = 0, lastY = 0, startX = 0, startY = 0;

                        const bbox = path.getBoundingBox();
                        const centerX = (bbox.x1 + bbox.x2) / 2;

                        for (const cmd of path.commands) {
                            const mx = (val: number) => centerX - (val - centerX);
                            if (cmd.type === 'M') {
                                smartMoveToStart(mx(cmd.x), cmd.y);
                                lastX = cmd.x; lastY = cmd.y; startX = cmd.x; startY = cmd.y;
                            } else if (cmd.type === 'L') {
                                lines.push(`G1 X${mx(cmd.x).toFixed(3)} Y${cmd.y.toFixed(3)} F${feedRate}`);
                                lastX = cmd.x; lastY = cmd.y;
                                currentX = mx(cmd.x); currentY = cmd.y;
                            }
                            else if (cmd.type === 'Z') {
                                lines.push(`G1 X${mx(startX).toFixed(3)} Y${startY.toFixed(3)} F${feedRate}`);
                                lastX = startX; lastY = startY;
                                currentX = mx(startX); currentY = startY;
                            } else if (cmd.type === 'Q' || cmd.type === 'C') {
                                const steps = 5;
                                for (let i = 1; i <= steps; i++) {
                                    const t = i / steps;
                                    let px, py;
                                    if (cmd.type === 'Q') {
                                        px = (1 - t) * (1 - t) * lastX + 2 * (1 - t) * t * cmd.x1 + t * t * cmd.x;
                                        py = (1 - t) * (1 - t) * lastY + 2 * (1 - t) * t * cmd.y1 + t * t * cmd.y;
                                    } else {
                                        // @ts-ignore
                                        px = Math.pow(1 - t, 3) * lastX + 3 * Math.pow(1 - t, 2) * t * cmd.x1 + 3 * (1 - t) * Math.pow(t, 2) * cmd.x2 + Math.pow(t, 3) * cmd.x;
                                        // @ts-ignore
                                        py = Math.pow(1 - t, 3) * lastY + 3 * Math.pow(1 - t, 2) * t * cmd.y1 + 3 * (1 - t) * Math.pow(t, 2) * cmd.y2 + Math.pow(t, 3) * cmd.y;
                                    }
                                    const mxPx = mx(px);
                                    lines.push(`G1 X${mxPx.toFixed(3)} Y${py.toFixed(3)} F${feedRate}`);
                                    currentX = mxPx; currentY = py;
                                }
                                lastX = cmd.x; lastY = cmd.y;
                            }
                        }

                        const advance = fontToUse.getAdvanceWidth(char, textShape.fontSize);
                        cursorX += advance + (textShape.letterSpacing || 0);
                    }
                } else {
                    const path = fontToUse.getPath(textShape.text, x, y, textShape.fontSize, { letterSpacing: textShape.letterSpacing });
                    let lastX = 0, lastY = 0, startX = 0, startY = 0;
                    for (const cmd of path.commands) {
                        const mx = (val: number) => {
                            if (mirrorMode === MirrorMode.WHOLE) return x - (val - x);
                            return val;
                        };
                        // Standard processing
                        if (cmd.type === 'M') {
                            smartMoveToStart(mx(cmd.x), cmd.y);
                            lastX = cmd.x; lastY = cmd.y; startX = cmd.x; startY = cmd.y;
                        } else if (cmd.type === 'L') {
                            lines.push(`G1 X${mx(cmd.x).toFixed(3)} Y${cmd.y.toFixed(3)} F${feedRate}`);
                            lastX = cmd.x; lastY = cmd.y;
                            currentX = mx(cmd.x); currentY = cmd.y;
                        } else if (cmd.type === 'Z') {
                            lines.push(`G1 X${mx(startX).toFixed(3)} Y${startY.toFixed(3)} F${feedRate}`);
                            lastX = startX; lastY = startY;
                            currentX = mx(startX); currentY = startY;
                        } else if (cmd.type === 'Q' || cmd.type === 'C') {
                            const steps = 5;
                            for (let i = 1; i <= steps; i++) {
                                const t = i / steps;
                                let px, py;
                                if (cmd.type === 'Q') {
                                    px = (1 - t) * (1 - t) * lastX + 2 * (1 - t) * t * cmd.x1 + t * t * cmd.x;
                                    py = (1 - t) * (1 - t) * lastY + 2 * (1 - t) * t * cmd.y1 + t * t * cmd.y;
                                } else {
                                    // @ts-ignore
                                    px = Math.pow(1 - t, 3) * lastX + 3 * Math.pow(1 - t, 2) * t * cmd.x1 + 3 * (1 - t) * Math.pow(t, 2) * cmd.x2 + Math.pow(t, 3) * cmd.x;
                                    // @ts-ignore
                                    py = Math.pow(1 - t, 3) * lastY + 3 * Math.pow(1 - t, 2) * t * cmd.y1 + 3 * (1 - t) * Math.pow(t, 2) * cmd.y2 + Math.pow(t, 3) * cmd.y;
                                }
                                const mxPx = mx(px);
                                lines.push(`G1 X${mxPx.toFixed(3)} Y${py.toFixed(3)} F${feedRate}`);
                                currentX = mxPx; currentY = py;
                            }
                            lastX = cmd.x; lastY = cmd.y;
                        }
                    }
                }
                break;
            }
        }
    };


    for (const shape of shapes) {
        await processShape(shape);
    }

    // Final Retract
    if (currentZ < safeHeight) {
        lines.push(`G0 Z${safeHeight}`);
    }

    lines.push('');
    lines.push('M5');
    lines.push('G0 X0 Y0');
    lines.push('M30');
    return lines.join('\n');
};

function calculateHeartPoint(t: number, shape: HeartShape, xOffset: number, yOffset: number): { x: number, y: number } {
    const hx = 16 * Math.pow(Math.sin(t), 3);
    const hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
    const scaleX = shape.width / 32;
    const scaleY = shape.height / 30;
    // Note: shape.x/y passed here already include offsets
    return {
        x: xOffset + (hx * scaleX),
        y: yOffset - (hy * scaleY)
    };
}
