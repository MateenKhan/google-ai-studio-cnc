import { Shape, ShapeType, MachineSettings, LineShape, PolylineShape, HeartShape } from '../types';
import opentype from 'opentype.js';

// Cache for loaded fonts
const fontCache: Record<string, opentype.Font> = {};

// Font URLs - Using GitHub Raw for reliable TTF access
const FONTS: Record<string, string> = {
  'Great Vibes': 'https://raw.githubusercontent.com/google/fonts/main/ofl/greatvibes/GreatVibes-Regular.ttf',
  'Roboto Mono': 'https://raw.githubusercontent.com/google/fonts/main/apache/robotomono/static/RobotoMono-Regular.ttf'
};

// Stick Font fallback
const SIMPLE_FONT: Record<string, number[][][]> = {
  'A': [[[0,0], [0.5,1], [1,0]], [[0.2,0.4], [0.8,0.4]]],
  'B': [[[0,0], [0,1], [0.8,1], [0.8,0.5], [0,0.5], [0.8,0.5], [0.8,0], [0,0]]],
  'C': [[[1,0.2], [0.5,0], [0,0.5], [0.5,1], [1,0.8]]],
  'D': [[[0,0], [0,1], [0.6,1], [1,0.5], [0.6,0], [0,0]]],
  'E': [[[1,0], [0,0], [0,1], [1,1]], [[0,0.5], [0.8,0.5]]],
  'F': [[[0,0], [0,1], [1,1]], [[0,0.5], [0.8,0.5]]],
  'G': [[[1,0.8], [1,0.5], [0.5,0.5]], [[0.5,0.5], [1,0.2], [0.5,0], [0,0.5], [0.5,1], [1,0.8]]],
  'H': [[[0,0], [0,1]], [[1,0], [1,1]], [[0,0.5], [1,0.5]]],
  'I': [[[0.5,0], [0.5,1]], [[0,0], [1,0]], [[0,1], [1,1]]],
  'J': [[[1,1], [1,0.2], [0.5,0], [0,0.2]]],
  'K': [[[0,0], [0,1]], [[1,1], [0,0.5], [1,0]]],
  'L': [[[0,1], [0,0], [1,0]]],
  'M': [[[0,0], [0,1], [0.5,0.5], [1,1], [1,0]]],
  'N': [[[0,0], [0,1], [1,0], [1,1]]],
  'O': [[[0.5,0], [0,0.5], [0.5,1], [1,0.5], [0.5,0]]],
  'P': [[[0,0], [0,1], [0.8,1], [0.8,0.5], [0,0.5]]],
  'Q': [[[0.5,0], [0,0.5], [0.5,1], [1,0.5], [0.5,0]], [[0.7,0.3], [1,0]]],
  'R': [[[0,0], [0,1], [0.8,1], [0.8,0.5], [0,0.5], [1,0]]],
  'S': [[[1,0.8], [0.5,1], [0,0.8], [1,0.2], [0.5,0], [0,0.2]]],
  'T': [[[0.5,0], [0.5,1]], [[0,1], [1,1]]],
  'U': [[[0,1], [0,0.2], [0.5,0], [1,0.2], [1,1]]],
  'V': [[[0,1], [0.5,0], [1,1]]],
  'W': [[[0,1], [0.2,0], [0.5,0.5], [0.8,0], [1,1]]],
  'X': [[[0,0], [1,1]], [[0,1], [1,0]]],
  'Y': [[[0,1], [0.5,0.5]], [[1,1], [0.5,0.5]], [[0.5,0.5], [0.5,0]]],
  'Z': [[[0,1], [1,1], [0,0], [1,0]]],
  '0': [[[0.5,0], [0,0.5], [0.5,1], [1,0.5], [0.5,0]], [[0,0], [1,1]]],
  '1': [[[0,0.8], [0.5,1], [0.5,0]], [[0,0], [1,0]]],
  '2': [[[0,0.8], [0.5,1], [1,0.8], [0,0], [1,0]]],
  '3': [[[0,0.8], [0.5,1], [1,0.8], [0.5,0.5]], [[0.5,0.5], [1,0.2], [0.5,0], [0,0.2]]],
  '4': [[[0.8,0], [0.8,1]], [[0,1], [0,0.4], [1,0.4]]],
  '5': [[[1,1], [0,1], [0,0.6], [0.5,0.6], [1,0.3], [0.5,0], [0,0.2]]],
  '6': [[[1,0.8], [0.5,1], [0,0.5], [0.5,0], [1,0.3], [0,0.5]]],
  '7': [[[0,1], [1,1], [0.5,0]]],
  '8': [[[0.5,0.5], [1,0.8], [0.5,1], [0,0.8], [0.5,0.5], [1,0.2], [0.5,0], [0,0.2], [0.5,0.5]]],
  '9': [[[0,0.2], [0.5,0], [1,0.5], [0.5,1], [0,0.7], [1,0.5]]],
  ' ': []
};

async function loadFont(fontFamily: string): Promise<opentype.Font | null> {
    const key = Object.keys(FONTS).find(k => fontFamily.includes(k.split(' ')[0]));
    if (!key) return null;
    
    const url = FONTS[key];
    if (fontCache[url]) return fontCache[url];

    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.warn(`Failed to fetch font ${fontFamily}: ${response.statusText}`);
            return null;
        }
        const buffer = await response.arrayBuffer();
        const font = opentype.parse(buffer);
        fontCache[url] = font;
        return font;
    } catch (err) {
        console.warn(`Error loading font ${fontFamily}:`, err);
        return null;
    }
}

export const generateGCode = async (shapes: Shape[], settings: MachineSettings): Promise<string> => {
  const { feedRate, safeHeight, cutDepth } = settings;
  const lines: string[] = [];

  // Header
  lines.push('; Generated by CNC Forge AI');
  lines.push('G21 ; Metric units');
  lines.push('G90 ; Absolute positioning');
  lines.push(`G0 Z${safeHeight} ; Move to safe height`);
  lines.push('M3 S1000 ; Spindle on');
  lines.push('');

  for (const shape of shapes) {
    lines.push(`; Shape: ${shape.type} (ID: ${shape.id})`);
    
    switch (shape.type) {
      case ShapeType.RECTANGLE:
        lines.push(`G0 X${shape.x.toFixed(3)} Y${shape.y.toFixed(3)}`);
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        lines.push(`G1 X${(shape.x + shape.width).toFixed(3)} Y${shape.y.toFixed(3)} F${feedRate}`);
        lines.push(`G1 X${(shape.x + shape.width).toFixed(3)} Y${(shape.y + shape.height).toFixed(3)}`);
        lines.push(`G1 X${shape.x.toFixed(3)} Y${(shape.y + shape.height).toFixed(3)}`);
        lines.push(`G1 X${shape.x.toFixed(3)} Y${shape.y.toFixed(3)}`);
        lines.push(`G0 Z${safeHeight}`);
        break;

      case ShapeType.CIRCLE:
        lines.push(`G0 X${(shape.x + shape.radius).toFixed(3)} Y${shape.y.toFixed(3)}`);
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        lines.push(`G2 X${(shape.x + shape.radius).toFixed(3)} Y${shape.y.toFixed(3)} I-${shape.radius.toFixed(3)} J0 F${feedRate}`);
        lines.push(`G0 Z${safeHeight}`);
        break;

      case ShapeType.LINE:
        const l = shape as LineShape;
        lines.push(`G0 X${l.x.toFixed(3)} Y${l.y.toFixed(3)}`);
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        lines.push(`G1 X${l.x2.toFixed(3)} Y${l.y2.toFixed(3)} F${feedRate}`);
        lines.push(`G0 Z${safeHeight}`);
        break;

      case ShapeType.POLYLINE:
        const p = shape as PolylineShape;
        if (p.points.length > 0) {
            lines.push(`G0 X${p.points[0].x.toFixed(3)} Y${p.points[0].y.toFixed(3)}`);
            lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
            for (let i = 1; i < p.points.length; i++) {
                lines.push(`G1 X${p.points[i].x.toFixed(3)} Y${p.points[i].y.toFixed(3)} F${feedRate}`);
            }
            lines.push(`G0 Z${safeHeight}`);
        }
        break;

      case ShapeType.HEART:
        const h = shape as HeartShape;
        const steps = 40;
        // Center x,y. Width/Height to scale.
        // Parametric heart:
        // x = 16 sin^3 t
        // y = 13 cos t - 5 cos 2t - 2 cos 3t - cos 4t
        // Bounds of standard formula approx: x: [-16, 16], y: [-17, 13] (approx height 30, width 32)
        // We need to scale to h.width and h.height and translate to h.x, h.y (center)
        
        const firstPt = calculateHeartPoint(0, h);
        lines.push(`G0 X${firstPt.x.toFixed(3)} Y${firstPt.y.toFixed(3)}`);
        lines.push(`G1 Z${-cutDepth} F${feedRate / 2}`);
        
        for (let i = 1; i <= steps; i++) {
            const t = (i / steps) * 2 * Math.PI;
            const pt = calculateHeartPoint(t, h);
            lines.push(`G1 X${pt.x.toFixed(3)} Y${pt.y.toFixed(3)} F${feedRate}`);
        }
        lines.push(`G0 Z${safeHeight}`);
        break;

      case ShapeType.TEXT:
        lines.push(`; Text: "${shape.text}"`);
        const fontToUse = shape.fontFamily && Object.keys(FONTS).some(f => shape.fontFamily!.includes(f)) 
            ? await loadFont(shape.fontFamily) 
            : null;

        if (fontToUse) {
            // High Quality Vector Path Generation
            const path = fontToUse.getPath(shape.text, shape.x, shape.y, shape.fontSize);
            // Convert Bezier curves to linear G-code segments
            let lastX = 0, lastY = 0;
            
            for (const cmd of path.commands) {
                switch (cmd.type) {
                    case 'M': // Move to
                        lines.push(`G0 Z${safeHeight}`);
                        lines.push(`G0 X${cmd.x.toFixed(3)} Y${cmd.y.toFixed(3)}`);
                        lines.push(`G1 Z${-cutDepth} F${feedRate/2}`);
                        lastX = cmd.x;
                        lastY = cmd.y;
                        break;
                    case 'L': // Line to
                        lines.push(`G1 X${cmd.x.toFixed(3)} Y${cmd.y.toFixed(3)} F${feedRate}`);
                        lastX = cmd.x;
                        lastY = cmd.y;
                        break;
                    case 'C': // Cubic Bezier
                    case 'Q': // Quadratic Bezier
                        // Simple linear subdivision
                        const steps = 5;
                        for(let i=1; i<=steps; i++) {
                             const t = i/steps;
                             let x, y;
                             if (cmd.type === 'Q') {
                                 x = (1-t)*(1-t)*lastX + 2*(1-t)*t*cmd.x1 + t*t*cmd.x;
                                 y = (1-t)*(1-t)*lastY + 2*(1-t)*t*cmd.y1 + t*t*cmd.y;
                             } else { // C
                                 x = Math.pow(1-t,3)*lastX + 3*Math.pow(1-t,2)*t*cmd.x1 + 3*(1-t)*Math.pow(t,2)*cmd.x2 + Math.pow(t,3)*cmd.x;
                                 y = Math.pow(1-t,3)*lastY + 3*Math.pow(1-t,2)*t*cmd.y1 + 3*(1-t)*Math.pow(t,2)*cmd.y2 + Math.pow(t,3)*cmd.y;
                             }
                             lines.push(`G1 X${x.toFixed(3)} Y${y.toFixed(3)} F${feedRate}`);
                        }
                        lastX = cmd.x;
                        lastY = cmd.y;
                        break;
                    case 'Z': // Close path
                        break;
                }
            }
            lines.push(`G0 Z${safeHeight}`);
        } else {
            // Stick Font Generation
            let currentX = shape.x;
            const letterSpacing = shape.letterSpacing || 0;
            const charSpacing = (shape.fontSize * 0.1) + letterSpacing;
            const charWidth = shape.fontSize * 0.6; 
            
            for (const char of shape.text.toUpperCase()) {
                const paths = SIMPLE_FONT[char] || SIMPLE_FONT['?'] || [];
                
                if (paths.length === 0 && char !== ' ') {
                   // Skip unknown
                } else if (char === ' ') {
                    // Just move
                } else {
                    paths.forEach(path => {
                       if (path.length === 0) return;
                       
                       const startX = currentX + (path[0][0] * charWidth);
                       const startY = shape.y - (path[0][1] * shape.fontSize); 

                       lines.push(`G0 X${startX.toFixed(3)} Y${startY.toFixed(3)}`);
                       lines.push(`G1 Z${-cutDepth}`);
                       
                       for (let i = 1; i < path.length; i++) {
                           const px = currentX + (path[i][0] * charWidth);
                           const py = shape.y - (path[i][1] * shape.fontSize);
                           lines.push(`G1 X${px.toFixed(3)} Y${py.toFixed(3)}`);
                       }
                       lines.push(`G0 Z${safeHeight}`);
                    });
                }
                currentX += charWidth + charSpacing;
            }
        }
    }
    lines.push('');
  }

  // Footer
  lines.push('M5 ; Spindle off');
  lines.push('G0 X0 Y0 ; Return home');
  lines.push('M30 ; End program');

  return lines.join('\n');
};

function calculateHeartPoint(t: number, shape: HeartShape): {x: number, y: number} {
    // Basic normalized heart
    const hx = 16 * Math.pow(Math.sin(t), 3);
    const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    
    // Scale and translate
    // Raw bounds approx x:[-16,16] w=32, y:[-17, 13] h=30
    // Flip Y because canvas Y is down, but formula Y is up
    
    const scaleX = shape.width / 32;
    const scaleY = shape.height / 30;
    
    return {
        x: shape.x + (hx * scaleX),
        y: shape.y - (hy * scaleY) // Invert Y logic for canvas
    };
}